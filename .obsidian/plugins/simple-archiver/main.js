/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var v=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var m=Object.prototype.hasOwnProperty;var F=(n,e)=>{for(var t in e)v(n,t,{get:e[t],enumerable:!0})},f=(n,e,t,i)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of g(e))!m.call(n,s)&&s!==t&&v(n,s,{get:()=>e[s],enumerable:!(i=p(e,s))||i.enumerable});return n};var A=n=>f(v({},"__esModule",{value:!0}),n);var y={};F(y,{default:()=>l});module.exports=A(y);var a=require("obsidian"),w={archiveFolder:"Archive"},l=class extends a.Plugin{async onload(){await this.loadSettings(),this.addCommand({id:"move-to-archive",name:"Move to archive",editorCheckCallback:(e,t,i)=>i.file&&!this.isFileArchived(i.file)&&i.file!=null?(e||this.archiveFile(i.file).then(r=>{new a.Notice(r.message)}),!0):!1}),this.addCommand({id:"move-out-of-archive",name:"Move out of archive",editorCheckCallback:(e,t,i)=>i.file&&this.isFileArchived(i.file)&&i.file!=null?(e||this.unarchiveFile(i.file).then(r=>{new a.Notice(r.message)}),!0):!1}),this.addSettingTab(new u(this.app,this)),this.registerEvent(this.app.workspace.on("file-menu",(e,t)=>{this.isFileArchived(t)||e.addItem(i=>{i.setTitle("Move to archive").setIcon("archive").onClick(async()=>{let s=await this.archiveFile(t);s.success?new a.Notice(s.message):new Error(s.message)})})})),this.registerEvent(this.app.workspace.on("files-menu",(e,t)=>{t.some(i=>this.isFileArchived(i))||e.addItem(i=>{i.setTitle("Move all to archive").setIcon("archive").onClick(async()=>{await this.archiveAllFiles(t)})})})),this.registerEvent(this.app.workspace.on("file-menu",(e,t)=>{this.isFileArchived(t)&&e.addItem(i=>{i.setTitle("Move out of archive").setIcon("archive-restore").onClick(async()=>{let s=await this.unarchiveFile(t);s.success?new a.Notice(s.message):new Error(s.message)})})})),this.registerEvent(this.app.workspace.on("files-menu",(e,t)=>{t.some(i=>!this.isFileArchived(i))||e.addItem(i=>{i.setTitle("Move all out of archive").setIcon("archive-restore").onClick(async()=>{await this.unarchiveAllFiles(t)})})}))}isFileArchived(e){return e.path.startsWith(this.settings.archiveFolder)}async archiveFile(e){if(this.isFileArchived(e))return{success:!1,message:"Item is already archived"};let t=(0,a.normalizePath)(`${this.settings.archiveFolder}/${e.path}`),i=this.app.vault.getAbstractFileByPath(t);return i!=null?new Promise(r=>{new h(this.app,"Replace archived item?",`An item called "${e.name}" already exists in the destination folder in the archive. Would you like to replace it?`,"Replace","Cancel",async()=>{await this.app.fileManager.trashFile(i);let o=await this.moveFileToArchive(e);r(o)},async()=>{r({success:!1,message:"Archive operation cancelled"})}).open()}):await this.moveFileToArchive(e)}async archiveAllFiles(e){let t=0;for(let i of e)(await this.archiveFile(i)).success&&t++;new a.Notice(`${t} files archived`)}async moveFileToArchive(e){var r;let t=(0,a.normalizePath)(`${this.settings.archiveFolder}/${(r=e.parent)==null?void 0:r.path}`);this.app.vault.getFolderByPath(t)==null&&await this.app.vault.createFolder(t);let s=(0,a.normalizePath)(`${t}/${e.name}`);try{return await this.app.fileManager.renameFile(e,s),{success:!0,message:`${e.name} archived successfully`}}catch(c){return{success:!1,message:`Unable to archive ${e.name}: ${c}`}}}async moveFileOutOfArchive(e){let t=e.path.substring(this.settings.archiveFolder.length+1),i=t.substring(0,t.lastIndexOf("/"));i&&this.app.vault.getFolderByPath(i)==null&&await this.app.vault.createFolder(i);try{return await this.app.fileManager.renameFile(e,t),{success:!0,message:`${e.name} unarchived successfully`}}catch(s){return{success:!1,message:`Unable to unarchive ${e.name}: ${s}`}}}async unarchiveFile(e){if(!this.isFileArchived(e))return{success:!1,message:"Item is not archived"};let t=e.path.substring(this.settings.archiveFolder.length+1),i=this.app.vault.getAbstractFileByPath(t);return i!=null?new Promise(r=>{new h(this.app,"Replace existing item?",`An item called "${e.name}" already exists in the original location. Would you like to replace it?`,"Replace","Cancel",async()=>{await this.app.fileManager.trashFile(i);let o=await this.moveFileOutOfArchive(e);r(o)},async()=>{r({success:!1,message:"Unarchive operation cancelled"})}).open()}):await this.moveFileOutOfArchive(e)}async unarchiveAllFiles(e){let t=0;for(let i of e)(await this.unarchiveFile(i)).success&&t++;new a.Notice(`${t} files unarchived`)}async loadSettings(){this.settings=Object.assign({},w,await this.loadData())}async saveSettings(){await this.saveData(this.settings)}},h=class extends a.Modal{constructor(e,t,i,s,r,c,o){super(e),this.setTitle(t),this.setContent(i),new a.Setting(this.contentEl).addButton(d=>d.setButtonText(s).setWarning().onClick(()=>{c(),this.close()})).addButton(d=>d.setButtonText(r).onClick(()=>{o(),this.close()}))}},u=class extends a.PluginSettingTab{constructor(e,t){super(e,t),this.plugin=t}display(){let{containerEl:e}=this;e.empty(),new a.Setting(e).setName("Archive folder").setDesc(`The folder to use as the Archive. If the folder doesn't exist, it will be created when archiving a note. Folder names must not contain "\\", "/" or ":" and must not start with ".".`).addText(t=>t.setPlaceholder("Archive folder").setValue((0,a.normalizePath)(this.plugin.settings.archiveFolder)).onChange(async i=>{this.setArchiveFolder(i)?await this.plugin.saveSettings():t.setValue(this.plugin.settings.archiveFolder)}))}validateArchiveFolderName(e){return!/^\.|[:/\\]\.|:/.test(e)}setArchiveFolder(e){return this.validateArchiveFolderName(e)?(this.plugin.settings.archiveFolder=e,!0):!1}};

/* nosourcemap */